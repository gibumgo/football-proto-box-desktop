# Flashscore 서비스 아키텍처 회고: 왜 우리는 코드를 분리해야 했나?

## 1. 초기 설계의 맹점: "서비스가 모든 것을 안다"

처음 `FlashscoreService`를 만들 때 우리는 직관적으로 생각했습니다.
> "Flashscore 크롤링 하는 거니까, URL 만들고 파일 저장하는 것도 여기서 다 하면 되겠지?"

이 생각은 **거대 클래스(God Class)**를 만드는 씨앗이 되었습니다.

### 🚨 무엇이 문제였나? (The Problem)

1.  **관심사의 오염 (Mixed Concerns)**
    - **서비스의 원래 목적**: "브라우저를 열어라", "페이지를 로딩해라", "파싱해라" 같은 **행동(Action)의 순서**를 관리하는 것입니다.
    - **잘못된 포함**: "URL에서 `/`를 기준으로 자르고...", "공백을 `_`로 바꾸고..." 같은 **데이터 조작(String Manipulation)** 로직이 섞여 있었습니다.
    - 결과적으로, **"어떻게(How)"**와 **"무엇을(What)"**이 뒤섞여 코드를 읽기 어렵게 만들었습니다.

2.  **변경의 파급 효과 (Ripple Effect)**
    - 만약 "파일 저장 규칙을 `_`에서 `-`로 바꾸자"라고 결정했다면?
    - 핵심 크롤링 로직이 있는 `FlashscoreService`를 수정해야 합니다. 실수로 브라우저 제어 코드를 건드릴 위험이 커집니다.
    - 단순한 **규칙 변경** 때문에 **핵심 로직**을 재배포해야 하는 상황이 발생합니다.

3.  **코드 스멜 (Code Smell)**
    - `_sanitize_filename`, `_get_safe_filename_parts` 같은 `private` 메서드들이 서비스 클래스 하단에 주렁주렁 매달려 있었습니다. 이는 클래스가 본연의 임무 외에 부수적인 일을 하고 있다는 강력한 신호입니다.

---

## 2. 해결책: 계층의 분리 (Layered Architecture)

우리는 이 문제를 **도메인 서비스(Domain Service)**와 **애플리케이션 서비스(Application Service)**로 나누어 해결했습니다.

### ✅ 도메인 서비스 (`FlashscorePathService`)
*   **성격**: **"불변의 규칙"**을 담당합니다.
*   **하는 일**:
    - "URL은 소문자여야 한다."
    - "파일 경로는 이 규칙을 따른다."
*   **특징**: 브라우저가 있든 없든, 웹사이트가 켜져 있든 꺼져 있든 **독립적으로 테스트 가능**합니다.

### ✅ 애플리케이션 서비스 (`FlashscoreService`)
*   **성격**: **"작업의 지휘자"**입니다.
*   **하는 일**:
    - "도메인 서비스야, URL 좀 만들어줘."
    - "브라우저야, 거기로 이동해."
    - "리포지토리야, 이거 저장해."
*   **변화**: 이제 복잡한 문자열 연산은 직접 하지 않고, **위임(Delegate)**합니다.

---

## 3. 비교 (Comparison)

| 구분 | 초기 설계 (As-Is) | 현재 설계 (To-Be) |
| :--- | :--- | :--- |
| **코드 위치** | `FlashscoreService` 내부에 `private` 메서드로 존재 | `FlashscorePathService` (Domain)로 분리 |
| **책임** | 실행 순서 관리 + 문자열/경로 조작 (SRP 위반) | 실행 순서 관리 (순수 Orchestration) |
| **변경된 이유** | 단순히 기능이 추가되면서 클래스가 비대해짐 | 유지보수성과 테스트 용이성을 위해 의도적으로 분리 |
| **수정 시** | 파일명 규칙을 바꾸려면 서비스를 수정해야 함 | 파일명 규칙은 도메인 서비스만 수정하면 됨 (안전) |

## 4. 제언: 향후 기획 및 설계 단계의 개선 방안 (Future Roadmap)

15년 차 시스템 기획자로서 이번 리팩토링 사례를 통해 도출한 **'앞으로의 기획/설계 단계 필수 점검 플로우'**를 제안합니다. 코드를 짜기 전에 다음 단계들을 선행하여 아키텍처 부채를 예방해야 합니다.

### 4.1. 도메인 정의 선행 (Domain-First Planning)
*   **현상**: 기능(Function) 명세서만 작성하고 바로 개발에 착수함. "크롤링한다"는 행위에 집중하여 도메인(규칙)과 애플리케이션(행위)이 혼재됨.
*   **개선안**: 기획 단계에서 **'불변의 규칙(Domain Rules)'**과 **'가변의 시나리오(Application Flow)'**를 명시적으로 구분하는 세션을 가져야 합니다.
    *   *Checklist*: "이 로직은 웹사이트가 사라져도 유효한 우리만의 규칙인가?" (Yes -> 도메인 서비스)

### 4.2. 인터페이스 주도 설계 (Interface-Driven Design)
*   **Flow 추가**: 구현보다 **'인터페이스 정의'**를 먼저 승인받는 절차 도입.
    *   기획자는 개발자에게 `FlashscoreService`가 아닌 `FlashscorePathService`의 입출력 설계를 먼저 요구해야 합니다.
    *   핵심 비즈니스 로직(파일명 생성, URL 규칙 등)이 메인 로직과 분리되어 있는지 설계 단계에서 검증 가능해집니다.

### 4.3. 확장성을 고려한 모듈화 (Modular Scalability)
*   **고려 사항**: "리그가 100개로 늘어난다면?", "저장 방식이 CSV에서 DB로 바뀐다면?"
*   이번 사례처럼 경로 생성 로직을 분리해 두지 않으면, 저장소 변경 시 크롤러 전체를 뜯어고쳐야 하는 리스크가 발생합니다.
*   **Action Plan**: 향후 모든 신규 서비스 기획 시 **'외부 의존성(External Dependency)'**과 **'내부 정책(Internal Policy)'**을 분리하는 아키텍처 다이어그램 작성을 의무화합니다.

**결론적으로**, 좋은 시스템은 '지금 잘 돌아가는 코드'가 아니라 **'미래의 변경을 우아하게 받아들이는 구조'**에서 나옵니다. 이번 리팩토링은 단순한 코드 정리가 아니라, 우리 시스템이 **지속 가능한 성장(Sustainable Growth)**을 하기 위한 중요한 체질 개선이었습니다.
