# 스크래핑 전략: 수집 순서와 처리 순서의 분리 (Decoupling Collection & Processing)

## 1. 개요 (Overview)
본 문서는 Flashscore와 같은 시계열 데이터(경기 결과)를 크롤링할 때 발생하는 "역순 수집"의 문제점과 이를 해결하기 위한 "정순 파싱" 아키텍처를 제안합니다.

## 2. 수집은 왜 역순이어야 하는가? (I/O Layer)
웹사이트(Flashscore)의 UI 구조상, 데이터 접근 효율성은 **최신순(Latest First)**이 가장 높습니다.

*   **UI 제한**: 기본적으로 가장 최근 라운드(예: 38R)가 상단에 노출됩니다.
*   **비용 효율**: "최신 데이터 업데이트"가 주 목적일 경우, 상단부터 훑다가 이미 수집된 데이터를 만나면 즉시 중단(Smart Resume)할 수 있습니다.
*   **결론**: 수집 단계에서는 웹사이트가 제공하는 순서(역순)를 그대로 따르는 것이 I/O 비용을 최소화하는 길입니다.

## 3. 파싱은 왜 정순이어야 하는가? (Logic Layer)
하지만 수집된 데이터를 해석(Parsing)할 때는 **시간의 흐름(Chronological Order)**을 따르는 것이 로직의 안정성을 보장합니다.

*   **역순 파싱의 위험성**: 시간을 거슬러 올라가는 로직(12월 -> 11월 -> 1월)은 "해가 바뀌는 시점"을 판단하기 위해 복잡한 조건문(Sawtooth Pattern 감지 등)을 필요로 합니다. 사소한 날짜 포맷 오인(DD.MM vs MM.DD)이 치명적인 연도 계산 오류를 유발합니다.
*   **정순 파싱의 직관성**: 데이터를 시간순으로 정렬한 뒤 처리하면, 연도 변경은 단순히 "12월에서 1월이 되었는가?"만 확인하면 됩니다.
    *   `if month < last_month: year += 1` (끝)

## 4. 제안하는 아키텍처 (To-Be Architecture)
향후 유사한 크롤러 설계 시, 다음 3단계 파이프라인을 권장합니다.

### Phase 1. 수집 (Collection) - *I/O Intensive*
*   브라우저를 통해 `Show More`를 누르며 HTML 데이터를 확보합니다.
*   이 단계에서는 순서를 신경 쓰지 않고, 최대한 빠르게 Raw Data를 모으는 데 집중합니다.

### Phase 2. 정규화 (Normalization) - *Data Transform*
*   메모리에 적재된 Raw Data 리스트를 **강제로 뒤집습니다 (`rows.reverse()`)**.
*   또는 날짜 기준으로 오름차순 정렬을 수행하여, 데이터가 과거 -> 현재 순으로 흐르도록 만듭니다.

### Phase 3. 파싱 (Parsing) - *CPU Intensive*
*   정렬된 데이터를 순회하며 비즈니스 로직(연도 계산, 승패 판정 등)을 수행합니다.
*   자연스러운 시간의 흐름을 따르므로 코드가 간결해지고 버그 발생 가능성이 현저히 낮아집니다.

## 5. 결론
**"UI가 주는 순서에 로직을 맞추지 마세요."**
수집(I/O)과 처리(Logic)의 순서를 분리(Decoupling)하는 것만으로도 시스템의 복잡도를 획기적으로 낮출 수 있습니다. 이는 유지보수하기 좋은 소프트웨어를 만드는 핵심 원칙 중 하나입니다.
